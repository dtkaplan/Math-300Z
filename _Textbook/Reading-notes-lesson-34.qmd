---
title: "Constructing a classifier"
output:
  html_document:
    theme: lumen
    toc: yes
    toc_float: yes
    css: NTI.css
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
lesson <- 34
source("../_startup.R")
```

::: {.hidden}
$$\newcommand{\Ptest}{\mathbb{P}}
\newcommand{\Ntest}{\mathbb{N}}
\newcommand{\given}{\ |\!\!|\  }$$
:::



There are many yes-or-no conditions. A patient has a disease or does not. A credit-card transaction is genuine or fraudulent. 

But it is not always straightforward to figure out at the time the patient comes to the clinic or the credit-card transaction is made, whether the condition is yes or no. If we could wait, the condition might reveal itself: the patient gets critically ill or the credit-hard holder complains about an unauthorized charge. But we can't wait. We want to treat the patient *before* he or she gets critically ill. We want to block the credit-card transaction before it is completed.

Instead of waiting, we measure whatever relevant variables we can when the patient arrives at the clinic or the credit-card transaction has been submitted for approval. For the patient, we might look at the concentration of specific markers for cancer in the blood. For the transaction, we might look at the shipping address to see if it matches the credit-card holder's genuine address. Such variables may provide an indication, imperfect though it may be, of whether the condition is yes or no.

A **classifier** is a statistical model used to *predict* the unknown outcome of a yes-or-no situation from information that is already available. This Lesson concerns three closely related topics about classifiers: how we collect data for training the model, how we summarize the performance of the classifier, and how we "tune" the classifier.


## Identifying cases

Consider this news report and note the time lag between collection of the dietary explanatory variables and the response variable---whether the patient developed pancreatic cancer.

> Higher vitamin D intake has been associated with a significantly reduced risk of pancreatic cancer, according to a study released last week.
> Researchers combined data from two prospective studies that included 46,771 men ages 40 to 75 and 75,427 women ages 38 to 65.  They identified 365 cases of pancreatic cancer over 16 years.
> Before their cancer was detected, subjects filled out dietary questionnaires, including information on vitamin supplements, and researchers calculated vitamin D intake.  After statistically adjusting^[That is, applying the methods of Lesson 28.] for age, smoking, level of physical activity, intake of calcium and retinol and other factors, the association between vitamin D intake and reduced risk of pancreatic cancer was still significant.
> Compared with people who consumed less than 150 units of vitamin D a day, those who consumed more than 600 units reduced their risk by 41 percent. - *New York Times*, 19 Sept. 2006, p. D6.

This was not an experiment; it was an observational study without any intervention to change anyone's diet.

## The training sample

In building a classifier, we have a similar situation. Perhaps we can perform the blood test today, but that gives us only the test result, not the subject's true condition. We might have to wait years for that condition to reveal itself. Only at that point can we measure the performance of the classifier.

To picture the situation, let's imagine many people enrolled in the study, some of whom have the condition and some who don't. On Day 1 of the study, we test everyone and get raw score on a scale from 0 to 40. The results are shown in @fig-case-control. Each glyph is a person. The varying locations are meant to help us later on; for now, just think of them as representing where each person lives in the world. The different shapes of glyph---circle, square, triangle---are meant to remind you that people are different from one another in age, gender, risk-factors, etc. 

Each person took a blood test. The raw result from that test is a score from 0 to 40. The distribution of scores is shown in the right panel of the figure. We also show the score in the world-plot;
the higher the raw score, the more blue the glyph. On Day 1, it isn't known who has the condition and who does not.


```{r echo=FALSE}
#| label: fig-case-control
#| fig-cap: "Day 1: The people participating in the study to develop the classifier. Each has been given a blood test which gives a score from zero (gray) to forty (blue). "
#| fig-cap-location: margin
P1 <- plot_people_score(Case_control)   # from _startup.R
set.seed(101)
P2 <- ggplot(Case_control %>% mutate(cond = "?"), 
       aes(y = raw_result, x = cond, color=log(1+raw_result)/log(41))) +
  geom_jitter(width=0.2, size=.2, alpha=0.9) +
  scale_shape_identity(guide="none") +
  scale_color_gradient(low="#AAAAAA", high="#0000FF", guide="none") +
  ylab("Test score") + xlab("") + theme_minimal()
gridExtra::grid.arrange(P1, P2, widths = c(.8, .2))
```

Having recorded the raw test results for each person, we wait. In the pancreatic cancer study, they waited 16 years for the cancer to reveal itself. 

... waiting ...

After the waiting period, we can add a new column to the original data; whether the person has the condition (C) or doesn't (H). 

@fig-compare-scores shows the distribution of raw test scores for the C group and the H group. The scores are those recorded on Day 1, but after waiting to find out the patients' conditions, we can subdivide them into those who have the condition (C) and those who don't (H).

```{r echo=FALSE, warning=FALSE}
#| label: fig-compare-scores
#| fig-cap: "The distribution of raw test scores. After we know the true condition, we can break down the test scores by condition."
#| fig-cap-location: margin
set.seed(101)
P4 <- ggplot(Case_control, 
       aes(y = raw_result, x = cond)) +
  geom_jitter(width=0.2, size=0.2, alpha=0.4) +
  geom_violin(color=NA, width=0.9, fill="blue", alpha=0.5)+
  scale_shape_identity(guide="none") +
  scale_color_gradient(low="#A0A0A0", high="#0000FF", guide="none") +
  ylab("") + xlab("") + theme_minimal() + labs(title="After waiting to find out ...")
gridExtra::grid.arrange(P2 + labs(title="Day 1") , P4, widths = c(.3, .7))
```

## Applying a threshold

To finish the classifier, we need to identify a "**threshold score**." Raw scores above this threshold will generate a $\Ptest$ test; scores below the threshold generate a $\Ntest$ test.

We can make a good guess at an appropriate threshold score from the presentation in the right panel of @fig-compare-scores. The objective in setting the threshold is to distinguish the C group from the H group. Setting the threshold at a score around 3 does a pretty good job. 

It helps to give names to the two test results: $\Ptest$ and $\Ntest$.
Anyone with a score above 3 has result $\Ptest$, anyone with a score below 3 has an $\Ntest$ result.

```{r echo=FALSE}
#| label: fig-divided-by-condition
#| fig-cap: "Blue is a $\\Ptest$ result, gray a $\\Ntest$ result."
P3a <- plot_people_final(Case_control %>% filter(cond=="C")) +
  labs(title="C group")
P3b <- plot_people_final(Case_control %>% filter(cond=="H")) +
  labs(title="H group")
P4 <- ggplot(Case_control , 
       aes(y = raw_result, x = cond, 
           color=ifelse(raw_result > 3, "blue", "gray"))) +
  geom_jitter(width=0.2, size=.2, alpha=0.9) +
  scale_shape_identity(guide="none") +
  scale_color_identity() +
  geom_hline(aes(yintercept=3), color="orange") +
  ylab("Test score") + xlab("") + theme_minimal()
gridExtra::grid.arrange(P3a, P4, P3b, widths = c(.4, .2, .4))
```





## False positives and false negatives


NARRATE @fig-divided-by-condition to point out the gray dots in the C group and the blue dots in the H group. These are errors. But there are two kinds of errors.

- False-positive: blue dots in the H group. The "positive" refers to the $\Ptest$ test result, the "false" simply means the test result was wrong.

- False-negative: gray dots in the C group. The "negative" refers to the $\Ntest$ result. Again, the "false" means simply that the test result is out of line with the actual condition of the person.


In the training sample shown in @fig-divided-by-condition, there are 300 people altogether and 17 false-negatives. This gives a false-negative rate of about 6%. Similarly there are 30 false-negatives, a false-positive rate of 10%. 



::: {.callout-note}
## Feature engineering: selling dog food

Naturally, the objective when building a classifier is to avoid errors. One way to avoid errors is by careful "**feature engineering**." Here, "features" refers to the inputs to the classifier model. Often, the designer of the classifier has multiple variables ("features") to work with. (See example.) Choosing a good set of features can be the difference between a successful classifier and one that makes so many mistakes as to be useless. 

We will use the name "Bullseye" to refer to 
a major, national, big-box retailing chain which sells, among many other products, dog food. Sales are largely determined by customer habits; people tend to buy where and what they have previously bought. There are many places to buy dog food, for instance pet supermarkets and grocery stores. 

One strategy for increasing sales involves discount coupons. A steep discount provides a consumer incentive to try something new and, maybe, leads to consumers forming new habits. But, from a sales perspective, there is little point in providing discounts to people who already have the habit of buying dog food from the retailer. Instead, it is most efficient to provide the discount only to people who don't yet have that habit  

The Bullseye marketing staff decided to build a classifier to identify pet owners who already shop at Bullseye but do not purchase dog food there. The data available, from Bullseye's "loyalty" program, consisted of individual customers' past purchases of the tens of thousands of products sold at Bullseye. 

Which of these many products to use as indicators of a customer's potential to switch to Bullseye's dog food? This is where feature engineering comes in. Searching through Bullseye's huge database, the feature engineers identified that customers who buy dog food also buy carpet cleaner. But many people buy carpet cleaner who don't buy dog food. The engineers searched for purchases might distinguish dog owners from other users of carpet cleaner. 

The feature engineers' conclusion: Send dog-food coupons to people who buy carpet cleaner but do not buy diapers. Admittedly, this will leave out the people who have both dogs and babies: these are false negatives. It will also lead to coupons being sent to petless, spill-prone people whose children, if any, have moved beyond diapers: false-positives. 

:::


## Threshold, sensitivity and specificity

In @fig-divided-by-condition the threshold between $\Ptest$ and $\Ntest$ is set at a score of 3. That might have been a good choice, but it pays to take a more careful look.

That graph is hard to read because the scores have a very long-tailed distribution; the large majority of scores are below 2 but the scores go up to 40. To make it easier to compare scores between the C and H groups,  @fig-compare-scores2 shows the scores on a nonlinear axis. Each score is marked as a letter: "P" means $\Ptest$, "N" means $\Ntest$. False results are colored red.


```{r echo=FALSE, warning=FALSE}
f <- with(Case_control, 
          splinefun(x = rank(raw_result), 
                    y = raw_result, 
                    method="monoH.FC"))
finv <- with(Case_control, 
          splinefun(x = raw_result, 
                    y = rank(raw_result), 
                    method="monoH.FC"))
```

```{r echo=FALSE}
#| label: fig-compare-scores2
#| fig-cap: "Redrawing the participants' scores from @fig-compare-scores on a nonlinear axis. Color marks whether the classifier gave a correct output."
#| fig-cap-location: margin
PNplot <- function(threshold=3) {
  Plot_data <- Case_control %>%
    mutate(test_result = raw_result <= threshold, 
           wrong = (cond=="H" & test_result) | 
             (cond=="C" & !test_result),
           test_shape = ifelse(test_result, "N", "P")) 
  
  
  ggplot(Plot_data, 
         aes(y = rank(raw_result), x = cond, 
             color=as.factor(wrong), shape=test_shape)) +
    geom_jitter(width=0.2, size=2, alpha=0.8) +
    scale_shape_identity() + 
    scale_color_manual(values=c("red", "darkgreen"), guide="none") +
    ylab("") + xlab("Condition") +
    geom_hline(aes(yintercept = finv(threshold)), color="orange") + 
    scale_y_continuous(breaks = c(), 
                       sec.axis = 
                         sec_axis(~ f(.), 
                                  breaks=c(0,0.5, 1,2,3, 5, 10, 40),
                                  name="Raw score")) + 
    theme_minimal() 
}
PNplot(threshold=3)
```


Moving the threshold up would reduce the number of false-positives. At the same time, the larger threshold would *increase* the number of false-negatives. @fig-two-thresholds shows what the situation would be if the threshold had been set at, say, 10 or 0.5. 

```{r echo=FALSE}
#| label: fig-two-thresholds1
#| fig-cap: "A **higher** threshold increases the number of false-negatives, but decreases false-positives."
#| column: margin
PNplot(threshold=10) + xlab("")
```

```{r echo=FALSE}
#| label: fig-two-thresholds2
#| fig-cap: "A **lower** threshold increases the number of false-positives, but decreases false-negatives."
#| column: margin
PNplot(threshold=0.5) + xlab("")
```

By setting the threshold larger, the number of false-negatives (red Ns in @fig-two-thresholds) increases, but the number of false-positives (red Ps) goes down. Setting the threshold lower reduces the number of false-negatives but increases the number of false-positives.

This trade-off between the number of false-positives and the number of false-negatives is characteristic of classifiers.

@fig-fraction-correct shows the overall pattern for false results versus threshold. At a threshold of 0, all test results are $\Ptest$. Hence, none of the C group results are false; if there are no $\Ntest$ results, there cannot be any false-negatives. On the other hand, all of the H group are false-positives.  

Increasing the threshold changes the results. At a threshold of 1, many of the H group---about 50%---are being correctly classified as $\Ntest$. Unfortunately, the higher threshold introduces some negative results for the C group. So the fraction of correct results in the C group goes down to about 90%.  This pattern continues: raising the threshold improves the fraction correct in the H group and lowers the fraction correct in the C group.  

There are two names given to the fraction of correct classifications, depending on whether one is looking at the C group or the H group. The fraction correct in the C group is called the "**sensitivity**" of the test. The fraction correct in the H group is the "**specificity**" of the test.

The sensitivity and the specificity, taken together, summarize the error rates of the classifier. Note that there are two error rates: one for the C group and another for the H group. @fig-fraction-correct shows that, depending on the threshold used, the sensitivity and specificity can be very different from one another.

```{r echo=FALSE}
#| label: fig-fraction-correct
#| fig-cap: "The choice of threshold determines the number of correct results."
#| fig-cap-location: margin
Plot_data <- Case_control %>%
    mutate(test_result = raw_result <= 3, 
           wrong = (cond=="H" & test_result) | 
             (cond=="C" & !test_result),
           test_shape = ifelse(test_result, "N", "P")) 
For_graph <- Plot_data %>%
  mutate(rank_score=finv(raw_result)) %>%
  arrange(raw_result) %>%
  group_by(cond) %>%
  mutate(frac_below = row_number()/150) %>%
  mutate(
    frac_wrong = ifelse(cond=="H", frac_below, 1-frac_below)) 
  
ggplot(For_graph, aes(x=raw_result, y=frac_wrong, color=cond)) +
  geom_line() +
  scale_x_sqrt(breaks=c(0, 1, 2, 3, 5, 10, 20, 30, 40)) +
  annotate("text", label="sensitivity vs threshold", x=10, y=.48,  color="red",angle=-45) +
  annotate("text", label="specificity vs threshold", x=.5, y=.45,  color="cyan3",angle=70) +
  ylab("Fraction correct") + xlab("Threshold") 
```

Ideally, both the sensitivity and specificity would be 100%. In practice, high sensitivity means lower specificity and *vice versa*. 

Sensitivity and specificity will be particularly important in Lesson 35 when we take into consideration the **prevalence**, that is, the fraction of the population with condition C 


